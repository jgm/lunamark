* TODO code comments/cleanup for lunadoc

* TODO man pages for lunamark, lunadoc
  (use existing shells)

* TODO add lunadoc to rock?

* TODO metadata as yaml-style set off by --- ---
  or, why not lua itself, instead of yaml? then we don't need a yaml
  parser.
  {
  title = "My great book",
  author = "John",
  abstract: [[
    This is the abstract. It is pretty
    long.]]
  }
  I suppose some kind of sandboxing would be needed to prevent
  running of arbitrary code. see http://lua-users.org/wiki/SandBoxes
  see sand.lua, which allows:
  ---
  title = "My book"
  author = "John"
  io.write("doesn't print")
  ---
  This technique could be extended to things like:
  ---
  title = "My book"
  bibliography = loadbib("mybib.bib")
  ---
  or
  ---
  bibliography = { book1: { ... },
                   book2: { ... } }
  ---
  would be nice to allow metadata at end of document, too.

* TODO update readme

* TODO gh-pages website
  [ ] README/description page
  [ ] include benchmarks
  [ ] pages for library API
  [ ] man pages

* TODO release
  [ ] email to luarocks list
  [ ] email to lua list
  [ ] email to markdown-discuss

* TODO fenced code block extension

* TODO pandoc title block extension

* TODO Use leg for lunadoc
  /Users/jgm/Downloads/leg/doc/grammar.html 
  and also consider leg's method of making the grammar modifiable

* TODO alternative indented block with metadata?

  This is text.

     code {
       in indented = block
       }
  (haskell)

  More text.

* TODO other metadata?
* TODO math extension

* TODO add library documentation
  - all writers have common set of functions, which can be documented once
  - then we need a list of writers + descriptions + information on options
  - readers just export one function, which again can be documented once
    + info on options
  - lunamark.util exports several functions which need documentation
* TODO add config file?
* TODO add man page

* TODO # in ordered lists extension

* TODO layout: indentation options?
* TODO Add metadata, return table as second value
* TODO latex reader - write peg
* TODO mathml - look at pandoc2?

* TODO make epub tool
* TODO make pdf tool
* TODO documentation, including extending writer + parser

* TODO add command-line arguments to lunadoc
* TODO add templates for lunadoc (html, latex using cosmo)

Notes on a possible macro system:  Simply add a function
to the writer:

    W.name = function(last,first)
      return first .. writer(space) .. writer.strong(last)
    end

    W.repeat = function(num,x)
      return string.rep(x, tonumber(num))
    end

When lunamark encounters %name{<inlines>}{<inlines>}
or %repeat[7]{Hi there%space}, it simply calls the writer.name function.

Note that writer.space is currently not a function; maybe that should
change for uniformity.  We may want macros with no arguments that
need to be functions: e.g. %currenttime.

Probably we'd need several types of arguments:

* parsed inline lists
* parsed block lists
* raw text

Also we'd have to know whether to parse as a block or an inline.
So perhaps we'd need two different kinds of macros.

* inline macros:

        %name{<inlines>}  -- with inline argument
        %name[raw text]   -- with raw argument

* block macros

        .admonition{<inlines>}{|  -- multiline block
        <blocks>
        |}

        .startsource[|
        multiline raw text - first newline ignored

        |]

These macros are all on the writer side. What about the reader side?
E.g. what if we want a macro

    #include[myfile.txt]

that reads myfile.txt and parses the source as markdown?
This can't happen in the writer.  But there could be a way to
register a reader macro.  This would simply call a match-time
parser function that directly modifies the input string.


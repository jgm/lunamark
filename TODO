* TODO definition list extension (read term as raw, parse later)
* TODO fenced code block extension
* TODO pandoc title block extension

* TODO in lunadoc, use metadata -- see luadoc for standard fields
    @author <text>
    An author of the module or file.
    @copyright <text>
    The copyright notice of the module or file. LuaDoc adds a Â© sign between the label (Copyright) and the given text (e.g. 2004-2007 Kepler Project).
    @field
    Describe a table field definition.
    @param <word> <text>
    Describe function parameters. It requires the name of the parameter and its description.
    @release <text>
    Free format string to describe the module or file release.
    @return <text>
    Describe a returning value of the function. Since Lua can return multiple values, this tag should appear more than once.
    @see <text>
    Refers to other descriptions of functions or tables.
    @usage <text>
    Describe the usage of the function or variable.
    Infered Tags
    The following tags would be normally infered by LuaDoc, but they can be used to override the infered value.
    @class <word>
    If LuaDoc cannot infer the type of documentation (function, table or module definition), the programmer can specify it explicitly.
    @description
    The description of the function or table. This is usually infered automatically.
    @name <word>
    The name of the function or table definition. This is usually infered from the code analysis, and the programmer does not need to define it. If LuaDoc can infer the name of the function automatically it's even not recomended to define the name explicitly, to avoid redundancy.

* TODO add documentation for lunadoc
* TODO add lunadoc to rock?
* TODO document with lunadoc.

* TODO alternative indented block with metadata?

  This is text.

     code {
       in indented = block
       }
  (haskell)

  More text.

* TODO other metadata?
* TODO math extension

* TODO add library documentation
  - all writers have common set of functions, which can be documented once
  - then we need a list of writers + descriptions + information on options
  - readers just export one function, which again can be documented once
    + info on options
  - lunamark.util exports several functions which need documentation
* TODO add config file?
* TODO add groff man writer and template
* TODO add man page

* TODO # in ordered lists extension
* TODO gh-pages website (at least README, library API, benchmarks)

* TODO layout: indentation options?
* TODO Add metadata, return table as second value
* TODO latex reader - write peg
* TODO mathml - look at pandoc2?

* TODO make epub tool
* TODO make pdf tool
* TODO documentation, including extending writer + parser

* TODO add command-line arguments to lunadoc
* TODO add templates for lunadoc (html, latex using cosmo)

Notes on a possible macro system:  Simply add a function
to the writer:

    W.name = function(last,first)
      return first .. writer(space) .. writer.strong(last)
    end

    W.repeat = function(num,x)
      return string.rep(x, tonumber(num))
    end

When lunamark encounters %name{<inlines>}{<inlines>}
or %repeat[7]{Hi there%space}, it simply calls the writer.name function.

Note that writer.space is currently not a function; maybe that should
change for uniformity.  We may want macros with no arguments that
need to be functions: e.g. %currenttime.

Probably we'd need several types of arguments:

* parsed inline lists
* parsed block lists
* raw text

Also we'd have to know whether to parse as a block or an inline.
So perhaps we'd need two different kinds of macros.

* inline macros:

        %name{<inlines>}  -- with inline argument
        %name[raw text]   -- with raw argument

* block macros

        .admonition{<inlines>}{|  -- multiline block
        <blocks>
        |}

        .startsource[|
        multiline raw text - first newline ignored

        |]

These macros are all on the writer side. What about the reader side?
E.g. what if we want a macro

    #include[myfile.txt]

that reads myfile.txt and parses the source as markdown?
This can't happen in the writer.  But there could be a way to
register a reader macro.  This would simply call a match-time
parser function that directly modifies the input string.


#!/usr/bin/env lua

--- This program reads a number of source files, scans them
-- for special comment blocks beginning with '---', and writes
-- an HTML file documenting each module to the doc directory.
--
-- There must be blank space between the opening dashes and
-- any following text.
--
-- If the comment block immediately precedes a declaration
-- of a function or variable, the name is extracted automatically.
--
-- Each file is assumed to be a module.  The 'module' keyword need
-- not be used.
--
-- Documentation is parsed as markdown.

local lunamark = require("lunamark")
local cosmo = require("cosmo")
local lpeg = require("lpeg")

local destdir = "doc"

local function extract_comments(f)
  local commentlines = {}
  local chunks = {}
  local collect = false
  local decl
  io.input(f)
  for l in io.lines() do
    local m = l:match("^%s*%-%-%-%s(.*)")
    if m then
      collect = true
      table.insert(commentlines,m)
    elseif collect then
      local n = l:match("^%s*%-%-%-?%s?(.*)")
      if n then
        table.insert(commentlines,n)
      else
        collect = false
        decl = l:match("function%s+(.-%))") or l:match("([^%s%=]+)%s*=")
        if decl then decl = string.gsub(decl,"M%.","") end  -- strip off M. which puts declaration in module
        table.insert(chunks, { contents = table.concat(commentlines,"\n"), decl = decl })
        commentlines = {}
      end
    end
  end
  return chunks
end

local template = [[
<html>
<head>
<title>$modname</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="lunadoc.css" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="module">$modname</h1>
$contents
</div>
<div id="index">
$index
</div>
</body>
</html>
]]

local decltemplate = [[
<div id="$id">
<h3 class="declaration">$name</h3>
$contents
</div>
]]

local css = [[
body { font-family: Arial, sans-serif; }
code,pre { font-family: Monaco, monospace; }
div#index { position: absolute; left: 1em; top: 1em; width:14em; border-right: 1px solid grey; }
div#content { position: absolute; left: 15em; top: 0em; padding-left: 2em; max-width: 40em; padding-bottom: 1em; }
]]

local index_table = {}

local function get_modname(s)
  return s:gsub("%.lua$",""):gsub("/",".")
end

for i=1,#arg do
  local modname = get_modname(arg[i])
  table.insert(index_table, "<p><a href=\"" .. modname .. ".html\">" .. modname .. "</a></p>")
end

local index = table.concat(index_table,"\n")

writer = lunamark.writer.html.new()

local identchar = lpeg.R("AZ","az","09") + lpeg.P("_")
local modname = identchar^1 * (lpeg.P(".") * identchar^1)^0
local declname = identchar^1
local crossref = lpeg.P("@") * lpeg.C(modname) * lpeg.Cs((lpeg.P("#") / "" * declname)^-1)
               / function(s,f)
                   local lab = s
                   if f then lab = lab .. "." .. f end
                   local src = s .. ".html"
                   if f then src = src .. "#" .. f end
                   return writer.link(lab, src, "")
                 end

local converter = lunamark.reader.markdown.new(writer,{smart=true, custom_inline = crossref})

for i=1,#arg do
  local f = arg[i]
  local chunks = extract_comments(f)
  local modname = get_modname(f)
  local decls = {}
  for _,chunk in ipairs(chunks) do
    local decl = chunk.decl
    local declid = decl and decl:match("^[^%(]*")
    if decl then
      local decltext = cosmo.fill(decltemplate, { name = decl, id = declid, contents = converter(chunk.contents) })
      table.insert(decls, decltext)
    else
      table.insert(decls, converter(chunk.contents))
    end
  end
  local page = cosmo.fill(template, { modname = modname, index = index, contents = table.concat(decls) })
  local file = io.open(destdir .. "/" .. modname .. ".html", "w")
  file:write(page)
  file:close()
end

local file = io.open(destdir .. "/lunadoc.css", "w")
file:write(css)
file:close()

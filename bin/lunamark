#!/usr/bin/env lua
-- lunamark program

local lunamark = require("lunamark")
local alt_getopt = require("alt_getopt")
local cosmo = require("cosmo")

local function ensure_one_of(optval,s,ary)
  for i=1,#ary do
    if ary[i]==s then return true end
  end
  lunamark.util.err("Illegal value for " .. optval ..
     "\nLegal values are: " .. table.concat(ary,", "))
end

local version = [[
lunamark 0.2 (c) 2009-2011 John MacFarlane
]]

local usage = [[
Usage: lunamark [options] [file..] - convert text between formats

Options:
  --to,-t FORMAT             Target format (see --help-formats)
  --from,-f FORMAT           Source format (see --help-formats)
  --layout,-l LAYOUT         Whitespace in output (default|compact|minimize)
  --extensions,-X EXTENSIONS Syntax extensions to use (see --help-extensions)
  --output,-o FILE           Output file
  --standalone,-s            Add header and footer
  --template,-T FILE         Insert output into template
  --data,-d K=V[,K=V..]      Set metadata to be passed to template
  --strict,-0                Disable markdown extensions
  --version,-V               Version information
  --help,-h                  This message

FORMAT can be markdown or html for the source, and
markdown, html, html5, docbook, latex, context, or man for the target.

LAYOUT can be default, compact (no unnecessary blank lines), or
minimize (no unnecessary blank space).

EXTENSIONS is a comma-separated list of extensions, each optionally prefixed
by + (enable) or - (disable).  The following extensions are defined,
with the default setting given in parentheses:
  (-) containers    Put sections in containers (e.g. div or section tags)
  (+) startnum      Start number of an ordered list is significant
  (-) smart         Smart typography (quotes, dashes, ellipses)
  (-) preservetabs  Don't expand tabs to spaces
]]

local long_opts = {
  to = "t",
  from = "f",
  layout = "l",
  extensions = "X",
  output = "o",
  standalone = "s",
  template = "T",
  data = "d",
  strict = "0",
  version = "V",
  help = "h"
}

local short_opts = "t:f:l:X:o:sT:d:0Vh"

local optarg,optind = alt_getopt.get_opts(arg, short_opts, long_opts)

if optarg.h then
  io.write(usage)
  os.exit(0)
end

if optarg.V then
  io.write(version)
  os.exit(0)
end

local from = optarg.f or "markdown"
local to = optarg.t or "html"

ensure_one_of("--from,-f", from, {"markdown","html"})
ensure_one_of("--to,-t", to,
  {"markdown","html","html5","docbook","latex","context","man"})

local reader = lunamark.reader[from]
if not reader then
  lunamark.util.err("Unknown reader: " .. tostring(from), 3)
end

local extensions = {  -- defaults
  containers = false,
  startnum = true,
  smart = false,
  preservetabs = false,
}

if optarg["0"] then
  extensions = {}
end

local extensions_opt = optarg.X or ""
for x in extensions_opt:gmatch("[%+%-]?[%a]+") do
  local val = true
  if x:sub(1,1) == "+" then
    val = true
    x = x:sub(2)
  elseif x:sub(1,1) == "-" then
    val = false
    x = x:sub(2)
  end
  if type(extensions[x]) ~= "boolean" then
    lunamark.util.err("Unrecognized extension: ", x)
  else
    extensions[x] = val
  end
end

local writer_options = extensions

local layout = optarg["l"] or "default"
ensure_one_of("--layout,-l",layout,{"default","compact","minimize"})
writer_options.layout = layout

local writer = lunamark.writer[to].new(writer_options)
if not writer then
  lunamark.util.err("Unknown writer: " .. tostring(to), 5)
end

local args = {}
for i=optind,#arg do
  table.insert(args,arg[i])
end

local reader_options = extensions
local parse = reader.new(writer, reader_options)

local inp
if #args == 0 then
  inp = io.read("*all") .. "\n"
else
  inpt = {}
  for _,f in ipairs(args) do
    io.input(f)
    table.insert(inpt, io.read("*all"))
  end
  inp = table.concat(inpt, "\n") .. "\n"
end
if inp:find("\r",1,true) then
  inp = inp:gsub("\r\n","\n") -- convert DOS line endings
end

local body, metadata = parse(inp)

local output = optarg.o
io.output(output)

local standalone = optarg.s
local template = optarg.T

if standalone and not template then
  template = "default"
end

if template then
  local contents = lunamark.util.find_template(template, to)
  local data = {}
  if optarg.d then
    for x in string.gmatch(optarg.d, "[%w_]+=[^,]+") do
      local k,v = string.match(x, "([^=]*)=(.*)")
      data[k] = v
    end
  end
  if metadata then data = metadata end
  data.body = body
  data.timestamp = os.date("%Y-%m-%d %X")
  data.sources = args
  data["if"] = cosmo.cif  -- this activates the "if" keyword
  local result = cosmo.fill(contents, data)
  io.write(result)
else
  io.write(body)
end

if not template then
  io.write("\n")
end

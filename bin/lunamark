#!/usr/bin/env lua
-- lunamark program

--[===[
@startman
# NAME

lunamark - converts markdown to many formats

# SYNOPSIS

lunamark [options] [file..]

# DESCRIPTION

Lunamark is a lua library and command-line program for conversion of markdown
to other textual formats. Currently HTML, Docbook, ConTeXt, LaTeX, and Groff man
are the supported output formats, but it is easy to add new writers or modify
existing ones. The markdown parser is written using a PEG grammar and can also
be modified by the user.

Lunamark's markdown parser currently supports the following extensions (which
can be turned on or off individually):

  - Smart typography (fancy quotes, dashes, ellipses)
  - Significant start numbers in ordered lists
  - Footnotes
  - Definition lists

More extensions will be supported in later versions.

The library is as portable as lua and has very good performance.
It is slightly faster than the author's own C library
[peg-markdown](http://github.com/jgm/peg-markdown).

# OPTIONS

`--to,-t` *format*
:   Specify format for output.
    *format* can be `html`, `html5`, `dzslides`, `docbook`, `latex`, `context`, or `man`.
`--layout,-l` *layout*
:   Control whitespace in output.
    *layout* can be `default` (blank lines between block-level elements),
    `compact` (avoid unnecessary blank lines), or `minimize` (avoid
    all unnecessary space).
`--extensions,-X` *extensions*
:   Use the specified syntax extensions in parsing markdown.
    *extensions* is a comma-separated list of extensions, each optionally
    prefixed by `+` (enable) or `-` (disable).  See EXTENSIONS, below, for
    a list of supported extensions.  The keyword 'all' may also be used,
    to set all extensions simultaneously.
`--output,-o` *file*
:   Write output to *file*.
`--standalone,-s`
:   Add header and footer to the document, so that it is a functional
    standalone document, not a fragment.  Use the default template
    for the writer, unless `--template,-T` is used.
`--template,-T` *file*
:   Insert converted text and metadata into a template.  See TEMPLATES,
    below, for template format.  Implies `--standalone,-s`.
`--data,-d` *key=value[,key=value..]*
:   Set metadata fields to be passed to template.  Argument is a list
    of *key=value* pairs, separated by commas.
`--strict,-0`
:   Disable all markdown extensions.
`--version,-V`
:   Print version information.
`--help,-h`
:   This message

# EXTENSIONS

The following extensions are defined, with the default setting given in parentheses:

`(-) containers`
:   Put sections in containers (`div` tags for `html` writer,
    `section` tags for `html5` or `dzslides`).
`(-) slides`
:   Like `containers`, but do not allow containers to nest.
    The container for a section will end before the container for
    a subsection begins.  This is usually what is wanted
    for HTML5 slide shows.
`(-) startnum`
:   Start number of an ordered list is significant. In standard
    markdown, the starting number is irrelevant.  If this
    extension is selected, the starting number determines
    the starting number of the list in the output.  (The
    subsequent numbers are ignored, as in standard markdown.)
`(-) smart`
:   Smart typography. Straight quotes are turned into curly
    quotes, `--` into en dashes, `---` into em dashes, `...`
    into an ellipsis character.
`(-) preserve_tabs`
:   Don't expand tabs to spaces. Standard markdown expands all
    tabs, using a tabstop of 4 spaces.  This extension allows
    tabs to be preserved in literal code contexts.
`(-) notes`
:   Footnotes. TODO
`(-) definition_lists`
:   Definition lists, as in pandoc. TODO

# TEMPLATES

TODO cosmo templates, examples.

# EXAMPLES



# AUTHORS

Most of lunamark is written by John MacFarlane.  Hans Hagen
made some major performance improvements to the markdown
parser.  Khaled Hosny added the original ConTeXt writer.

@stopman
--]===]

local lunamark = require("lunamark")
local alt_getopt = require("alt_getopt")
local cosmo = require("cosmo")

local function ensure_one_of(optval,s,ary)
  for i=1,#ary do
    if ary[i]==s then return true end
  end
  lunamark.util.err("Illegal value for " .. optval ..
     "\nLegal values are: " .. table.concat(ary,", "))
end

local version = [[
lunamark 0.2
Copyright (C) 2009-2011 John MacFarlane
]]

local usage = [[
Usage: lunamark [options] [file..] - convert markdown to other formats

Options:
  --to,-t FORMAT             Target format
  --layout,-l LAYOUT         Whitespace in output (default|compact|minimize)
  --extensions,-X EXTENSIONS Syntax extensions to use
  --output,-o FILE           Output file
  --standalone,-s            Add header and footer
  --template,-T FILE         Insert output into template
  --data,-d K=V[,K=V..]      Set metadata to be passed to template
  --strict,-0                Disable markdown extensions
  --version,-V               Version information
  --help,-h                  This message

FORMAT can be html, html5, docbook, latex, context, or man.

LAYOUT can be default, compact (no unnecessary blank lines), or
minimize (no unnecessary blank space).

EXTENSIONS is a comma-separated list of extensions, each optionally prefixed
by + (enable) or - (disable).  The following extensions are defined,
with the default setting given in parentheses:
  (-) containers        Put sections in containers (e.g. div or section tags)
  (-) slides            Like containers, but do not nest them
  (-) startnum          Start number of an ordered list is significant
  (-) smart             Smart typography (quotes, dashes, ellipses)
  (-) preserve_tabs     Don't expand tabs to spaces
  (-) notes             Footnotes
  (-) definition_lists  Definition lists
The keyword 'all' may also be used, to set all extensions simultaneously.
]]

local long_opts = {
  to = "t",
  layout = "l",
  extensions = "X",
  output = "o",
  standalone = "s",
  template = "T",
  data = "d",
  strict = "0",
  version = "V",
  help = "h"
}

local short_opts = "t:l:X:o:sT:d:0Vh"

local optarg,optind = alt_getopt.get_opts(arg, short_opts, long_opts)

if optarg.h then
  io.write(usage)
  os.exit(0)
end

if optarg.V then
  io.write(version)
  os.exit(0)
end

local to = optarg.t or "html"
ensure_one_of("--to,-t", to,
  {"markdown","html","html5","dzslides","docbook","latex","context","man"})

local reader = lunamark.reader.markdown

local extensions = {  -- defaults
  containers = false,
  slides = false,
  startnum = false,
  smart = false,
  preserve_tabs = false,
  notes = false,
  definition_lists = false,
}

if optarg["0"] then
  extensions = {}
end

local extensions_opt = optarg.X or ""
for x in extensions_opt:gmatch("[%+%-]?[%a_]+") do
  local val = true
  if x:sub(1,1) == "+" then
    val = true
    x = x:sub(2)
  elseif x:sub(1,1) == "-" then
    val = false
    x = x:sub(2)
  end
  if x == "all" then
    for k,_ in pairs(extensions) do
      extensions[k] = val
    end
  elseif type(extensions[x]) ~= "boolean" then
    lunamark.util.err("Unrecognized extension: ", x)
  else
    extensions[x] = val
  end
end

local output = optarg.o
local ok, msg = pcall(function() io.output(output) end)
if not ok then
  lunamark.util.err("Could not open '" .. output .. "' for writing.\n" .. msg, 9)
end

local writer_options = extensions

local layout = optarg["l"] or "default"
ensure_one_of("--layout,-l",layout,{"default","compact","minimize"})
writer_options.layout = layout

local writer = lunamark.writer[to].new(writer_options)
if not writer then
  lunamark.util.err("Unknown writer: " .. tostring(to), 5)
end

local reader_options = extensions

local parse = reader.new(writer, reader_options)

local args = {}
for i=optind,#arg do
  table.insert(args,arg[i])
end

local inp
if #args == 0 then
  inp = io.read("*all") .. "\n"
else
  inpt = {}
  for _,f in ipairs(args) do
    local ok, msg = pcall(function() io.input(f) end)
    if ok then
      table.insert(inpt, io.read("*all"))
    else
      lunamark.util.err("Could not open file '" .. f .. "'", 7)
    end
  end
  inp = table.concat(inpt, "\n") .. "\n"
end
if inp:find("\r",1,true) then
  inp = inp:gsub("\r\n","\n") -- convert DOS line endings
end

local body, metadata = parse(inp)

local standalone = optarg.s
local template = optarg.T

local template_contents

if standalone and not template then
  template_contents = writer.template
end

if template then
  local template_name = template
  -- use writer name as extension if none provided
  if not template_name:match("%..+$") then
    template_name = template_name .. "." .. to
  end
  template_contents = lunamark.util.find_template(template_name)
  if not template_contents then
    lunamark.util.err("Could not find template '" .. template_name .. "'")
  end
end

if template_contents then
  local data = {}
  data.timestamp = os.date("%Y-%m-%d %X")
  data.sources = args
  if metadata then data = metadata end
  if optarg.d then
    for x in string.gmatch(optarg.d, "[%w_]+=[^,]+") do
      local k,v = string.match(x, "([^=]*)=(.*)")
      data[k] = writer.string(v)
    end
  end
  data.body = body
  data["if"] = cosmo.cif  -- this activates the "if" keyword
  local result = cosmo.fill(template_contents, data)
  io.write(result)
else
  io.write(body)
end

if not template_contents then
  io.write("\n")
end


